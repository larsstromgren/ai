import win32com.client as win32
import os, csv, datetime, sys

# ==== KONFIG ====
OUT_DIR = r"C:\Users\ah43886\Documents\Outlook_Exports"

TARGET_SMTP   = ""        # t.ex. "ditt.namn@din-domän.se" för att tvinga en viss brevlåda. Tomt = DefaultStore.
ALL_STORES    = False     # True = loopa alla stores (inkl. funktionsbrevlådor/Online Archive)
START_YEAR    = 1990      # tidig start
END_YEAR      = None      # None = fram till idag. Eller sätt t.ex. 2025
INCLUDE_SENT  = False     # True = ta med mappar under Skickat
ROOT_MODE     = "ROOT"    # "ROOT" = hela kontot, "INBOX" = bara Inkorg + undermappar
PER_YEAR_FILES= True      # True = en CSV per år, False = en enda stor fil
ONLY_MAIL     = True      # True = filtrera på MessageClass='IPM.Note' (riktiga mail)
STOP_FILE     = r"C:\Temp\STOP_EXPORT.txt"  # skapa filen för att avbryta mjukt

PR_SMTP = "http://schemas.microsoft.com/mapi/proptag/0x39FE001E"

# ==== HJÄLPARE ====
def ensure_dir(p):
    os.makedirs(p, exist_ok=True)

def ts():
    return datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

def folder_path(f):
    parts = []
    while f is not None and f.__class__.__name__ == "MAPIFolder":
        parts.append(f.Name)
        f = f.Parent
    return "\\".join(reversed(parts))

def is_descendant_of(child, ancestor):
    p = child
    while p is not None and p.__class__.__name__ == "MAPIFolder":
        if p.EntryID == ancestor.EntryID:
            return True
        p = p.Parent
    return False

def excluded_folder(folder, session):
    ns = session
    sent     = ns.GetDefaultFolder(5)   # Sent Items
    outbox   = ns.GetDefaultFolder(4)   # Outbox
    drafts   = ns.GetDefaultFolder(16)  # Drafts
    junk     = ns.GetDefaultFolder(23)  # Junk E-mail
    deleted  = ns.GetDefaultFolder(3)   # Deleted Items

    # Alltid exkludera dessa träd:
    for ex in [outbox, drafts, junk, deleted]:
        if ex is not None and is_descendant_of(folder, ex):
            return True

    # Skickat endast om flaggan ej är satt:
    if not INCLUDE_SENT and sent is not None and is_descendant_of(folder, sent):
        return True

    # Om ROOT_MODE = INBOX: tillåt bara Inkorg + dess undermappar
    if ROOT_MODE.upper() == "INBOX":
        inbox = session.GetDefaultFolder(6)  # Inbox
        if inbox is None:
            return True
        if folder.EntryID == inbox.EntryID:
            return False
        # annars måste mappen vara under Inkorg
        return not is_descendant_of(folder, inbox)

    return False

def safe_get_row(rw, name, default=""):
    try:
        return rw.Item(name)
    except Exception:
        try:
            return getattr(rw, name)
        except Exception:
            return default

def build_filter(d0, d1):
    # Bas: datum
    filt = f"[ReceivedTime] >= '{d0:%m/%d/%Y} 12:00 AM' AND [ReceivedTime] < '{d1:%m/%d/%Y} 12:00 AM'"
    # Endast riktiga mail?
    if ONLY_MAIL:
        # MessageClass finns i de flesta Stores; om inte, ignoreras i fallback
        filt += " AND [MessageClass] = 'IPM.Note'"
    return filt

def write_from_table(tbl, folder, writer):
    # Minimera kolumner (tål att PR_SMTP saknas)
    try:
        tbl.Columns.RemoveAll()
    except Exception:
        pass
    for col in ["EntryID", "ReceivedTime", "Subject", "SenderName", "SenderEmailAddress", "To", "CC", "MessageClass"]:
        try:
            tbl.Columns.Add(col)
        except Exception:
            pass
    try:
        tbl.Columns.Add(PR_SMTP)
    except Exception:
        pass

    n = 0
    while not tbl.EndOfTable:
        rw = tbl.GetNextRow()
        eid   = safe_get_row(rw, "EntryID", "")
        rec   = safe_get_row(rw, "ReceivedTime", "")
        mcls  = safe_get_row(rw, "MessageClass", "")
        if ONLY_MAIL and mcls and mcls.lower() != "ipm.note":
            continue
        subj  = safe_get_row(rw, "Subject", "")
        sname = safe_get_row(rw, "SenderName", "")
        sSMTP = safe_get_row(rw, PR_SMTP, "") or safe_get_row(rw, "SenderEmailAddress", "")
        to_s  = safe_get_row(rw, "To", "")
        cc_s  = safe_get_row(rw, "CC", "")
        writer.writerow([eid, rec, folder_path(folder), sname, sSMTP, subj, to_s, cc_s])
        n += 1
    return n

def process_folder(folder, writer, d0, d1, session):
    # Stoppsignal?
    if os.path.exists(STOP_FILE):
        print("\nStoppsignal upptäckt – avbryter.")
        sys.exit(0)

    if excluded_folder(folder, session):
        return 0

    filt = build_filter(d0, d1)
    wrote = 0

    # 1) Folder.GetTable
    try:
        tbl = folder.GetTable(filt)
    except Exception:
        tbl = None
    if tbl is not None:
        wrote += write_from_table(tbl, folder, writer)
    else:
        # 2) Items.GetTable
        try:
            its = folder.Items
            tbl = its.GetTable(filt)
            wrote += write_from_table(tbl, folder, writer)
        except Exception:
            # 3) Restrict fallback
            try:
                its = folder.Items
                its.Sort("[ReceivedTime]", True)
                rIts = its.Restrict(filt)
                for it in rIts:
                    if getattr(it, "Class", 0) == 43:  # olMail
                        try:
                            sSMTP = it.PropertyAccessor.GetProperty(PR_SMTP) or it.SenderEmailAddress
                        except Exception:
                            sSMTP = it.SenderEmailAddress
                        writer.writerow([
                            it.EntryID,
                            it.ReceivedTime,
                            folder_path(folder),
                            it.SenderName or "",
                            sSMTP or "",
                            it.Subject or "",
                            it.To or "",
                            it.CC or ""
                        ])
                        wrote += 1
            except Exception:
                pass

    # Rekursion
    for sub in folder.Folders:
        wrote += process_folder(sub, writer, d0, d1, session)
    return wrote

def process_store(store, session, year, writer):
    # Välj startmapp enligt ROOT_MODE
    if ROOT_MODE.upper() == "INBOX":
        root = session.GetDefaultFolder(6)  # Inbox
    else:
        root = store.GetRootFolder()

    total = 0
    for month in range(1, 13):
        d0 = datetime.datetime(year, month, 1)
        d1 = (d0 + datetime.timedelta(days=32)).replace(day=1)
        print(f"  {store.DisplayName[:40]:40s}  {year}-{month:02d} …", end="\r")
        month_count = process_folder(root, writer, d0, d1, session)
        total += month_count
        # kort progressrad:
        print(f"  {store.DisplayName[:40]:40s}  {year}-{month:02d}: {month_count:6d} rader")
    return total

def pick_store_by_smtp(session, smtp_lower):
    for acc in session.Accounts:
        try:
            if acc.SmtpAddress and acc.SmtpAddress.lower() == smtp_lower:
                return acc.DeliveryStore
        except Exception:
            pass
    return None

# ==== HUVUD ====
def main():
    ensure_dir(OUT_DIR)
    ol = win32.gencache.EnsureDispatch("Outlook.Application")
    session = ol.Session

    # Vilka stores?
    if TARGET_SMTP:
        st = pick_store_by_smtp(session, TARGET_SMTP.lower())
        if st is None:
            print(f"Hittade ingen store för {TARGET_SMTP}. Använder DefaultStore i stället.")
            stores = [session.DefaultStore]
        else:
            stores = [st]
    else:
        stores = list(session.Stores) if ALL_STORES else [session.DefaultStore]

    now = datetime.datetime.now()
    end_year = END_YEAR if END_YEAR else now.year

    grand_total = 0
    for st in stores:
        print(f"\n=== Export från: {st.DisplayName} ===")
        if PER_YEAR_FILES:
            # en fil per år
            for year in range(START_YEAR, end_year + 1):
                if datetime.datetime(year, 1, 1) > now:
                    break
                csv_path = os.path.join(OUT_DIR, f"Outlook_Export_{st.DisplayName.replace(os.sep,'-')}_{year}_{ts()}.csv")
                with open(csv_path, "w", newline="", encoding="utf-8") as f:
                    w = csv.writer(f)
                    w.writerow(["EntryID","ReceivedTime","FolderPath","SenderName","SenderSMTP","Subject","To","CC"])
                    yr_total = process_store(st, session, year, w)
                print(f"-> {year}: {yr_total} rader  |  {csv_path}")
                grand_total += yr_total
        else:
            # en stor fil
            csv_path = os.path.join(OUT_DIR, f"Outlook_Export_ALL_{st.DisplayName.replace(os.sep,'-')}_{ts()}.csv")
            with open(csv_path, "w", newline="", encoding="utf-8") as f:
                w = csv.writer(f)
                w.writerow(["EntryID","ReceivedTime","FolderPath","SenderName","SenderSMTP","Subject","To","CC"])
                for year in range(START_YEAR, end_year + 1):
                    if datetime.datetime(year, 1, 1) > now:
                        break
                    grand_total += process_store(st, session, year, w)
            print(f"-> Skrev till {csv_path}")

    print(f"\nKlar. Totalt skrivna rader: {grand_total}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nAvbrutet.")
        sys.exit(1)
